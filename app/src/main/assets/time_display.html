<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>C-Tune Clock</title>
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      background: #0d1117;
      color: #ffffff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      margin: 0;
      overflow: hidden;
      position: relative; /* Needed for absolute positioning of solar-times and sun */
      text-align: center;
    }
    .clock-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .time-section {
      margin: 0 10px;
      padding: 10px;
      text-align: left;
      opacity: 1; /* Start with opacity 1 */
      transition: opacity 0.5s ease-in-out; /* Add transition for opacity */
      /* display will be managed by JS */
    }
    /* Initially hide the non-default sections (handled by setDisplayState and switchMode JS) */
    /* #local-section, #ctu-section { display: none; opacity: 0; } - Remove this initial CSS rule */

    .label {
      font-size: 1rem;
      color: #8b949e;
      margin-bottom: 2px;
      white-space: nowrap;
    }
    .value {
      font-size: 2rem;
      font-weight: 600;
      margin-bottom: 16px;
      white-space: nowrap;
    }
    .time-hm {
      font-size: 4rem;
    }
    .time-sec {
      font-size: 2rem;
      margin-left: 4px;
    }

    /* --- Styling for Dawn/Dusk Times --- */
    .solar-times {
      position: absolute; /* Position relative to the body */
      bottom: 20px; /* Distance from the bottom */
      left: 20px; /* Distance from the left */
      right: 20px; /* Distance from the right */
      display: flex; /* Use flexbox to space items */
      justify-content: space-between; /* Push items to the corners */
      width: calc(100% - 40px); /* Adjust width based on left/right padding */
      pointer-events: none; /* Prevent clicks on this container */
      opacity: 0; /* Start with opacity 0 */
      transition: opacity 0.5s ease-in-out; /* Add a simple transition */
      /* visibility will be managed by JS for coordination with opacity */
      visibility: hidden;
    }

    /* Show solar times only when the body has the 'show-ctu' class */
    .show-ctu .solar-times {
      opacity: 1; /* Fade in */
      visibility: visible; /* Make visible */
    }

    .solar-time {
      font-size: 1.2rem;
      color: #8b949e;
      white-space: nowrap; /* Prevent wrapping */
    }
    .solar-time .icon {
      margin-right: 4px;
    }
    .solar-time .time {
      font-weight: 600;
    }

    /* --- Styling for the Sun Element --- */
    #sun {
      position: absolute;
      width: 20px;
      height: 20px;
      background: yellow;
      border-radius: 50%;
      box-shadow: 0 0 10px 5px rgba(255,223,0,0.7);
      transform: translate(-50%, -50%); /* Center the sun element on its coordinates */
      z-index: 10;
      opacity: 0; /* Start with opacity 0 */
      transition: opacity 0.5s ease-in-out; /* Add transition for opacity */
       /* display will be managed by JS */
      display: none;
    }
  </style>
</head>
<body>
<div class="clock-container">
  <div class="time-section" id="utc-section">
    <div class="label">Global (UTC)</div>
    <div class="value" id="utc-time">
      <span class="time-hm">Loading</span>
      <span class="time-sec">...</span>
    </div>
  </div>
  <div class="time-section" id="local-section">
    <div class="label" id="local-time-label">Local Time</div>
    <div class="value" id="local-time">
      <span class="time-hm">Loading</span>
      <span class="time-sec">...</span>
    </div>
  </div>
  <div class="time-section" id="ctu-section">
    <div class="label">Local (CTU)</div>
    <div class="value" id="ctu-time">
      <span class="time-hm">Loading</span>
      <span class="time-sec">...</span>
    </div>
  </div>
</div>
<div class="solar-times">
  <div id="dawn-time" class="solar-time">
    <span class="icon">↑</span>
    <span class="time">--:--</span>
  </div>
  <div id="dusk-time" class="solar-time">
    <span class="icon">↓</span>
    <span class="time">--:--</span>
  </div>
</div>
<div id="sun"></div>
<script>
  // Global variables for CTU time (seconds) and dawn/dusk (seconds since midnight)
  let currentCTUSeconds = 0;
  let dawnSeconds = null;
  let duskSeconds = null;
  // Clock mode: 0 = UTC, 1 = Local, 2 = CTU
  let currentState = 0;
  let isAnimating = false;
  const fadeDuration = 500; // Match CSS transition duration in milliseconds

  const utcSection = document.getElementById("utc-section");
  const localSection = document.getElementById("local-section");
  const ctuSection = document.getElementById("ctu-section");
  const sunElement = document.getElementById("sun");

  const sections = [utcSection, localSection, ctuSection]; // Array of sections for easy access

  // Function to set the display state without animation (for initial load)
  function setDisplayState(state) {
      sections.forEach((section, index) => {
          section.style.display = (index === state) ? "block" : "none";
          section.style.opacity = (index === state) ? "1" : "0";
      });

       // Set initial display/opacity for sun and solar times
      document.body.classList.remove("show-ctu");
      sunElement.style.display = "none";
      sunElement.style.opacity = "0";

      if (state === 2) { // If initial state is CTU
          // Calculate and set initial sun position before making it visible
          updateSunPosition();

          document.body.classList.add("show-ctu"); // Show solar times
          sunElement.style.display = "block"; // Show sun block
          sunElement.style.opacity = "1"; // Show sun opacity
      }
  }

  // Initialize to the default mode (UTC)
  setDisplayState(currentState);

  // --- Event Listeners for Switching Modes (Swipe Only) ---
   let startX = null;
   let startTime = null;
   // clickTimeout is no longer needed as we are not detecting clicks for mode switching
   // let clickTimeout = null;
   const clickThreshold = 50; // Minimum distance for a swipe to be registered (in pixels)
   const swipeTimeThreshold = 500; // Maximum time for a gesture to be considered a swipe (in milliseconds)


   document.body.addEventListener("touchstart", function (event) {
     // Only track if not animating and it's a single touch
     if (event.touches.length === 1 && !isAnimating) {
       startX = event.touches[0].clientX;
       startTime = new Date().getTime();
        // No click detection timeout needed for swipe-only
     }
   });

   document.body.addEventListener("touchend", function (event) {
     // Only process if a gesture was started (startX is not null), not animating, and it's a single touch end
     if (startX === null || isAnimating || event.changedTouches.length !== 1) return;

     const endX = event.changedTouches[0].clientX;
     const swipeDistance = endX - startX;
     const swipeTime = new Date().getTime() - startTime;

     // Check if the gesture is a swipe based on distance and time
     if (swipeTime < swipeTimeThreshold && Math.abs(swipeDistance) > clickThreshold) {
       // It's a swipe!
       if (swipeDistance > 0) {
         switchMode(1); // Swipe right (forward mode)
       } else {
         switchMode(-1); // Swipe left (backward mode)
       }
     }
     // --- Removed the else if block that handled clicks/taps ---

     startX = null; // Reset tracking after gesture ends
     startTime = null;
   });

   // Add mouse events for desktop compatibility (simplified for swipe detection)
   document.body.addEventListener("mousedown", function (event) {
       // Only track if not animating
       if (!isAnimating) {
            startX = event.clientX;
            startTime = new Date().getTime();
       }
   });

   document.body.addEventListener("mouseup", function (event) {
       // Only process if a gesture was started (startX is not null) and not animating
       if (startX === null || isAnimating) return;

       const endX = event.clientX;
       const swipeDistance = endX - startX;
       const swipeTime = new Date().getTime() - startTime;

       // Check if the gesture is a swipe based on distance and time (using the same thresholds)
       if (swipeTime < swipeTimeThreshold && Math.abs(swipeDistance) > clickThreshold) {
            // It's a swipe!
            if (swipeDistance > 0) {
                switchMode(1); // Swipe right (forward mode)
            } else {
                switchMode(-1); // Swipe left (backward mode)
            }
       }
        // No specific click handling needed here for mode switching

       startX = null; // Reset tracking after gesture ends
       startTime = null;
   });

   // --- Remove the separate click event listener entirely ---
   // document.body.addEventListener("click", function(event) { ... });


  // Function to handle the mode switching animation
  function switchMode(delta) {
    if (isAnimating) {
        return;
    }
    isAnimating = true;

    const prevState = currentState;
    currentState = (currentState + delta + 3) % 3;
    const prevSection = sections[prevState];
    const nextSection = sections[currentState];

    // --- Start Fade Out ---
    prevSection.style.opacity = "0";
    if (prevState === 2) {
        sunElement.style.opacity = "0";
        document.body.classList.remove("show-ctu");
    }


    // Wait for fade out to complete
    setTimeout(() => {
        prevSection.style.display = "none"; // Hide previous section

        // --- Start Fade In ---
        nextSection.style.display = "block"; // Show next section
        nextSection.style.opacity = "0"; // Set opacity to 0 before fading in

        // If switching *to* CTU (currentState === 2)
        if (currentState === 2) {
             // Calculate and set the sun's position *before* making it visible and fading in
            updateSunPosition();

            sunElement.style.display = "block"; // Make sun element block
            // Use a small delay before setting opacity to 1
            setTimeout(() => {
                 sunElement.style.opacity = "1"; // Start fading in sun
                 document.body.classList.add("show-ctu"); // Start fading in solar times
            }, 10); // Small delay

        } else {
             // If switching *from* CTU, ensure sun is hidden after fading out
             sunElement.style.display = "none";
             sunElement.style.opacity = "0";
        }

        // Trigger fade in for next section
        setTimeout(() => {
            nextSection.style.opacity = "1"; // Start fading in next section
            isAnimating = false; // Animation finished
        }, 10);


    }, fadeDuration); // Match the CSS transition duration for fade out
  }


  // Function to update time strings. Assumes time strings in "HH:MM:SS" format for main times.
  function formatTime(timeString, elementId) {
    const parentElement = document.getElementById(elementId);
    const hmElement = parentElement.querySelector(".time-hm");
    const secElement = parentElement.querySelector(".time-sec");

    const parts = timeString.split(':');
    const hoursMinutes = parts[0] + ':' + parts[1]; // HH:MM
    const seconds = parts[2]; // SS

    hmElement.innerText = hoursMinutes;
    secElement.innerText = seconds;
  }

  // Called from Kotlin to update the times.
  // Expects:
  // - utcTime, localTime, ctuTime in "HH:MM:SS" format;
  // - dawnTime and duskTime in "HH:mm" format.
  function updateTimes(utcTime, localLabel, localTime, ctuTime, dawnTime, duskTime) {
    // Update the labels and main time values
    document.getElementById("local-time-label").innerText = localLabel;
    formatTime(utcTime, "utc-time");
    formatTime(localTime, "local-time");
    formatTime(ctuTime, "ctu-time");

    // Update Dawn and Dusk times (assumes HH:mm format)
    document.querySelector("#dawn-time .time").innerText = dawnTime;
    document.querySelector("#dusk-time .time").innerText = duskTime;

    // Update global variables for sun position calculation.
    const parts = ctuTime.split(":");
    if (parts.length === 3) {
      const hours = parseInt(parts[0], 10);
      const minutes = parseInt(parts[1], 10);
      const seconds = parseInt(parts[2], 10);
      currentCTUSeconds = hours * 3600 + minutes * 60 + seconds;
    } else {
       currentCTUSeconds = 0;
    }

    const dawnParts = dawnTime.split(":");
    if (dawnParts.length === 2) {
      dawnSeconds = parseInt(dawnParts[0], 10) * 3600 + parseInt(dawnParts[1], 10) * 60;
    } else {
      dawnSeconds = null;
    }

    const duskParts = duskTime.split(":");
    if (duskParts.length === 2) {
      duskSeconds = parseInt(duskParts[0], 10) * 3600 + parseInt(duskParts[1], 10) * 60;
    } else {
      duskSeconds = null;
    }
  }

  // Update the sun's position and color based on CTU time.
  // This function calculates and sets the position/color.
  // Visibility (display, opacity, transition) is managed by switchMode.
  function updateSunPosition() {
    const sun = document.getElementById("sun");

     // Get screen dimensions and calculate radii
    const centerX = window.innerWidth / 2;
    const centerY = window.innerHeight / 2;
    const screenWidth = window.innerWidth;
    const screenHeight = window.innerHeight;

    const minDimension = Math.min(screenWidth, screenHeight);
    const maxDimension = Math.max(screenWidth, screenHeight);

    const smallRadius = minDimension / 2; // 1/2 of min
    const bigRadius = maxDimension / 2; // 1/2 of max

    let rx, ry;
    if (screenWidth > screenHeight) { // Landscape
        rx = bigRadius; // Horizontal radius is big
        ry = smallRadius; // Vertical radius is small
    } else { // Portrait
        rx = smallRadius; // Horizontal radius is small
        ry = bigRadius; // Vertical radius is big
    }

    // Use currentCTUSeconds (time from 00:00 CTU)
    const secondsOfDay = (typeof currentCTUSeconds === "number" && !isNaN(currentCTUSeconds))
      ? currentCTUSeconds
      : 0;

    const secondsAt1200 = 12 * 3600; // 12:00 PM in seconds from midnight
    const secondsInDay = 24 * 3600; // 24 hours in seconds

    // Time in seconds from 12:00 PM (wrapping around midnight)
    const timeFrom1200 = (secondsOfDay - secondsAt1200 + secondsInDay) % secondsInDay;

    // Angle (clockwise from upward vertical) based on time from 12:00 PM
    // Angle goes from 0 (upward vertical) to 2*PI (full circle clockwise)
    const angle = (timeFrom1200 / secondsInDay) * 2 * Math.PI; // Angle in radians

    // Position the sun along the ellipse
    // x = centerX + rx * sin(angle)
    // y = centerY - ry * cos(angle) because screen y is downwards and we want y up
    const x = centerX + rx * Math.sin(angle);
    const y = centerY - ry * Math.cos(angle);


    // Set sun position
    // We are already using transform: translate(-50%, -50%) in CSS to center the element itself
    // So we set the top-left corner of the element to the calculated (x, y)
    sun.style.left = x + "px";
    sun.style.top = y + "px";

    // Set sun color according to CTU seconds relative to dawn/dusk.
    let sunColor = "yellow";
    let sunBoxShadow = "0 0 10px 5px rgba(255, 223, 0, 0.7)";

    if (dawnSeconds !== null && duskSeconds !== null && typeof secondsOfDay === "number") {
      const transitionDuration = 600;

      if (Math.abs(secondsOfDay - dawnSeconds) <= transitionDuration || Math.abs(secondsOfDay - duskSeconds) <= transitionDuration) {
         sunColor = "red";
         sunBoxShadow = "0 0 10px 5px rgba(255, 0, 0, 0.7)";
      } else if (secondsOfDay < dawnSeconds || secondsOfDay >= duskSeconds) {
         sunColor = "white";
         sunBoxShadow = "0 0 10px 5px rgba(255, 255, 255, 0.7)";
      } else { // Daytime
         sunColor = "yellow";
         sunBoxShadow = "0 0 10px 5px rgba(255, 223, 0, 0.7)";
      }
    }

    sun.style.background = sunColor;
    sun.style.boxShadow = sunBoxShadow;
  }

  // Update sun position periodically (every second)
  setInterval(updateSunPosition, 1000);
  // Update position immediately on load
  updateSunPosition();
  // Update position on window resize
  window.addEventListener("resize", updateSunPosition);
</script>
</body>
</html>